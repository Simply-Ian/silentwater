/*!
    \page lifecycle Жизненный цикл приложения
    \section lifecycle_main Что происходит при запуске приложения?

    1. Стартует расположенная в Controller.cpp функция main() :
    \code {.cpp}
    int main(int argc, char** argv){
        Controller cont;
        char FILE_NAME[] = "RedRing.fb2";
        cont.load_book(argc == 1? FILE_NAME : argv[1]);
        cont.loop();
        return 0;
    }
    \endcode
    Она создает экземпляр класса Controller. Конструктор Controller::Controller() создает и настраивает метку номера страницы,
    навешивает callback-и экранным кнопкам "вправо" и "влево", загружает шрифт для рендеринга страницы.
    После этого main() запускает его метод load_book():
    \code {.cpp}
    void Controller::load_book(char* path){
        model.load_fb2(path);
        model.split_into_words();
        create_word_matrix();
        build_up_pages();

        view.doc_links_name = model.doc_links_name;
    }
    \endcode
    Controller::load_book() запускает метод Model::load_fb2(). 
        -# Он открывает файл по переданному пути в кодировке
        по умолчанию, разбирает корневой тег <?xml> и получает информацию о кодировке текста.
        \todo Для определения кодировки текста файл должен открываться "вручную", чтобы избежать полного парсинга. Нужно только
        считать значение одного атрибута тега, расположенного в первой строке. Это можно реализовать без средств pugixml.

        Затем внутри model::load_fb2() вызывается функция ::load_text(). Она снова открывает файл и конвертирует его в UTF-8 с помощью
        libiconv. Далее происходит XML-парсинг, строится дерево тегов. Определяется префикс ссылок. И, наконец, запускается Walker.
            1. Walker рекурсивно обходит все дерево тегов, игнорируя теги вне секции <body> . На каждом шаге он обновляет
            Walker::cur_style и Walker::cur_attrs . Если текущий тег задает стиль для вложенного в него текста или имеет атрибуты,
            значения стилей сохраняются в Walker::cur_style с указанием глубины, на которой находится тег; названия и значения
            атрибутов сохраняются в Walker::cur_attrs. На каждом шаге из Walker::cur_style удаляются стили, установленные более
            глубокими тегами.
            \todo Очистка cur_attrs
            2. Когда Walker доходит до листа -- текстового содержимого, он создает экземпляр Fragment с накопленными 
            стилями и добавляет по указателю в вектор Model::fragments. Если Walker встречает пустую линию, он добавляет Fragment 
            без стилей, содержащий специальную метку "\n". В начале каждого абзаца в Model::fragments добавляется Fragment
            со специальной меткой "&&&".
    
        -# Дальше срабатывает метод Model::split_into_words()/ Объекты Fragment, содержащие более одного слова, для удобства верстки
        разбиваются 
        на Fragment-ы, содержащие 1 слово. Каждый из полученных объектов Fragment сохраняет атрибуты и стили исходного Fragment
        (см. отдельную страницу).

        -# Выполняется метод Controller::create_word_matrix(). Для каждого Fragment создается объект SWText, оформляется
        в соответствии с описанными в Fragment::styles стилями; ссылкам назначаются функции-callback для событий мыши. Настроенные
        объекты SWText помещаются в Controller::word_matrix .

        -# Метод Controller::build_up_pages() верстает страницы, используя информацию о размере Controller::view::pageSprite. 
        Сверстанные страницы помещаются в Controller::pages .

        -# Происходит донастройка Controller::view (во view передается префикс ссылок внутри FB2-документа)

    2. Запускается Controller::loop(). Этот метод берет на себя управление программой. В ней находится главный GUI-цикл
    \todo Написать подробнее о Controller::loop() 
*/